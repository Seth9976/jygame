using System;
using System.Runtime.InteropServices;

namespace System.Reflection.Emit
{
	/// <summary>Provides support for alternative ways to generate the Microsoft intermediate language (MSIL) and metadata for a dynamic method, including methods for creating tokens and for inserting the code, exception handling, and local variable signature blobs. </summary>
	// Token: 0x020002CF RID: 719
	[ComVisible(true)]
	public class DynamicILInfo
	{
		// Token: 0x0600245C RID: 9308 RVA: 0x00082060 File Offset: 0x00080260
		internal DynamicILInfo()
		{
		}

		/// <summary>Gets the dynamic method whose body is generated by the current instance.</summary>
		/// <returns>A <see cref="T:System.Reflection.Emit.DynamicMethod" /> object representing the dynamic method for which the current <see cref="T:System.Reflection.Emit.DynamicILInfo" /> object is generating code.</returns>
		// Token: 0x17000666 RID: 1638
		// (get) Token: 0x0600245D RID: 9309 RVA: 0x00082068 File Offset: 0x00080268
		[MonoTODO]
		public DynamicMethod DynamicMethod
		{
			get
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Gets a token, valid in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" />, representing the signature for the associated dynamic method.</summary>
		/// <returns>A token that can be embedded in the metadata and the MSIL stream for the associated dynamic method.</returns>
		/// <param name="signature">A <see cref="T:System.Byte" /> array containing the signature.</param>
		// Token: 0x0600245E RID: 9310 RVA: 0x00082070 File Offset: 0x00080270
		[MonoTODO]
		public int GetTokenFor(byte[] signature)
		{
			throw new NotImplementedException();
		}

		/// <summary>Gets a token, valid in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" />, representing a dynamic method to be called from the associated method.</summary>
		/// <returns>A token that can be embedded in the MSIL stream for the associated dynamic method, as the target of an MSIL instruction.</returns>
		/// <param name="method">A <see cref="T:System.Reflection.Emit.DynamicMethod" /> object representing the dynamic method to call.</param>
		// Token: 0x0600245F RID: 9311 RVA: 0x00082078 File Offset: 0x00080278
		[MonoTODO]
		public int GetTokenFor(DynamicMethod method)
		{
			throw new NotImplementedException();
		}

		/// <summary>Gets a token, valid in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" />, representing a field to be accessed from the associated dynamic method.</summary>
		/// <returns>A token that can be used as the operand of an MSIL instruction that accesses fields, in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" /> object.</returns>
		/// <param name="field">A <see cref="T:System.RuntimeFieldHandle" /> structure representing the field to be accessed.</param>
		// Token: 0x06002460 RID: 9312 RVA: 0x00082080 File Offset: 0x00080280
		[MonoTODO]
		public int GetTokenFor(RuntimeFieldHandle field)
		{
			throw new NotImplementedException();
		}

		/// <summary>Gets a token, valid in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" />, representing a method to be accessed from the associated dynamic method.</summary>
		/// <returns>A token that can be used as the operand of an MSIL instruction that accesses methods, such as <see cref="F:System.Reflection.Emit.OpCodes.Call" /> or <see cref="F:System.Reflection.Emit.OpCodes.Ldtoken" />, in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" /> object.</returns>
		/// <param name="method">A <see cref="T:System.RuntimeMethodHandle" /> structure representing the method to be accessed.</param>
		// Token: 0x06002461 RID: 9313 RVA: 0x00082088 File Offset: 0x00080288
		[MonoTODO]
		public int GetTokenFor(RuntimeMethodHandle method)
		{
			throw new NotImplementedException();
		}

		/// <summary>Gets a token, valid in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" />, representing a type to be used in the associated dynamic method.</summary>
		/// <returns>A token that can be used as the operand of an MSIL instruction that requires a type, in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" /> object.</returns>
		/// <param name="type">A <see cref="T:System.RuntimeTypeHandle" /> structure representing the type to be used.</param>
		// Token: 0x06002462 RID: 9314 RVA: 0x00082090 File Offset: 0x00080290
		[MonoTODO]
		public int GetTokenFor(RuntimeTypeHandle type)
		{
			throw new NotImplementedException();
		}

		/// <summary>Gets a token, valid in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" />, representing a string literal to be used in the associated dynamic method.</summary>
		/// <returns>A token that can be used as the operand of an MSIL instruction that requires a string, in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" /> object.</returns>
		/// <param name="literal">The string to be used.</param>
		// Token: 0x06002463 RID: 9315 RVA: 0x00082098 File Offset: 0x00080298
		[MonoTODO]
		public int GetTokenFor(string literal)
		{
			throw new NotImplementedException();
		}

		/// <summary>Gets a token, valid in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" />, representing a method on a generic type.</summary>
		/// <returns>A token that can be used as the operand of an MSIL instruction that accesses methods, such as <see cref="F:System.Reflection.Emit.OpCodes.Call" /> or <see cref="F:System.Reflection.Emit.OpCodes.Ldtoken" />, in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" /> object.</returns>
		/// <param name="method">A <see cref="T:System.RuntimeMethodHandle" /> structure representing the method.</param>
		/// <param name="contextType">The generic type the method belongs to.</param>
		// Token: 0x06002464 RID: 9316 RVA: 0x000820A0 File Offset: 0x000802A0
		[MonoTODO]
		public int GetTokenFor(RuntimeMethodHandle method, RuntimeTypeHandle contextType)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sets the code body of the associated dynamic method.</summary>
		/// <param name="code">A <see cref="T:System.Byte" /> array containing the MSIL stream.</param>
		/// <param name="maxStackSize">The maximum number of items on the operand stack when the method is executing.</param>
		// Token: 0x06002465 RID: 9317 RVA: 0x000820A8 File Offset: 0x000802A8
		[MonoTODO]
		public void SetCode(byte[] code, int maxStackSize)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sets the code body of the associated dynamic method.</summary>
		/// <param name="code">A pointer to a byte array containing the MSIL stream.</param>
		/// <param name="codeSize">The number of bytes in the MSIL stream.</param>
		/// <param name="maxStackSize">The maximum number of items on the operand stack when the method is executing.</param>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="codeSize" /> is less than 0.</exception>
		// Token: 0x06002466 RID: 9318 RVA: 0x000820B0 File Offset: 0x000802B0
		[CLSCompliant(false)]
		[MonoTODO]
		public unsafe void SetCode(byte* code, int codeSize, int maxStackSize)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sets the exception metadata for the associated dynamic method.</summary>
		/// <param name="exceptions">A <see cref="T:System.Byte" /> array containing the exception metadata.</param>
		// Token: 0x06002467 RID: 9319 RVA: 0x000820B8 File Offset: 0x000802B8
		[MonoTODO]
		public void SetExceptions(byte[] exceptions)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sets the exception metadata for the associated dynamic method.</summary>
		/// <param name="exceptions">A pointer to a byte array containing the exception metadata.</param>
		/// <param name="exceptionsSize">The number of bytes of exception metadata.</param>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="exceptionSize" /> is less than 0.</exception>
		// Token: 0x06002468 RID: 9320 RVA: 0x000820C0 File Offset: 0x000802C0
		[CLSCompliant(false)]
		[MonoTODO]
		public unsafe void SetExceptions(byte* exceptions, int exceptionsSize)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sets the local variable signature that describes the layout of local variables for the associated dynamic method.</summary>
		/// <param name="localSignature">A <see cref="T:System.Byte" /> array containing the layout of local variables for the associated <see cref="T:System.Reflection.Emit.DynamicMethod" />.</param>
		// Token: 0x06002469 RID: 9321 RVA: 0x000820C8 File Offset: 0x000802C8
		[MonoTODO]
		public void SetLocalSignature(byte[] localSignature)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sets the local variable signature that describes the layout of local variables for the associated dynamic method.</summary>
		/// <param name="localSignature">A <see cref="T:System.Byte" /> array containing the layout of local variables for the associated <see cref="T:System.Reflection.Emit.DynamicMethod" />.</param>
		/// <param name="signatureSize">The number of bytes in the signature.</param>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="signatureSize" /> is less than 0.</exception>
		// Token: 0x0600246A RID: 9322 RVA: 0x000820D0 File Offset: 0x000802D0
		[MonoTODO]
		[CLSCompliant(false)]
		public unsafe void SetLocalSignature(byte* localSignature, int signatureSize)
		{
			throw new NotImplementedException();
		}
	}
}
